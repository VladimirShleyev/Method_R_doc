#renv::init() # инициализация виртуального окружения
renv::install("tidyr", "stringr") # установка библиотеки из CRAN
renv::snapshot() # делаем снимок версий библиотек в нашем виртуальном окружении
# фиксируем этот список в .lock-файле для возможности восстановления
# renv::restore() # команда отктиться к предыдушему удачному обновления библиотек

# ------------------- 
# Лабораторная работа №3:
# Очистка данных. Строки. Regex.

library(tidyr)
library(stringr)


who <- tidyr::who # набор данных от Всемирной организации здравоохранения
<- <- <- <- #  статистика заболевания туберкулезом по странам мира
  
  who # изучим набор данных
# он содержит избыточные данные, странные коды переменных, много отсутствующих значений

# соберем вместе все столбцы и удалим отсутствующие значения

who1 <- who %>%
  gather(
    new_sp_m014:newrel_f65, key = "key",
    value = "cases",
    na.rm = TRUE
  )
who1

# Получим представление о структуре значений в стобце key. Подсчитаем значения:

who1 %>%
  count(key)

# первые три буквы названия говорят о каких случаях заболеваний идет речь:
# новых (new) или старых (ul)
# reel - рецидивный
# up - внелегочный
# sun - легочный, не диагностируемый с помощью мазка
# spa - легочный, диагностируемый с помощью мазка

# шестая буква - пол пациента

# оставшиеся цифры - дают пол пациента

# Заменим названия newrel на new_rel:

who2 <- who1 %>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel"))

who2

# разделим значения в каждом коде за 2 прохода с помощью функции separate()
# первый проход разделит коды в тех местах, где встречается символ подчеркивания, после этого столбец можно опустить, тк он постоянный в этом наборе
# одновременно опустим столбы iso2, iso3, тк они избыточны
who3 <- who2 %>%
  separate(key, c("new", "type", "sexage"), sep = "_")

who3

who3 %>%
  count(new)

who4 <- who3 %>%
  select(-new, -iso2, -iso3)

who5 <- who4 %>%
  separate(sexage, c("sex", "age"), sep = 1)
who5

# набор данных приведен к аккуратному виду

# То же самое, только короче в одном канале:

who %>%
  gather(code, value, new_sp_f014:newrel_f65, na.rm = TRUE) %>%
  mutate(
    code = stringr::str_replace(code, "newrel", "new_rel")
  ) %>%
  separate(code, c("new", "var", "sexage")) %>%
  select(-new, -iso2, -iso3) %>%
  separate(sexage, c("sex", "age"), sep = "1")

rm(who, who1, who2, who3, who4, who5)

# итак, очистка данных - это, преобразование дата-сета к аккуратному виду:
# 1) устранение проблем с признаками
# 2) устранение проблем с записями

# Это - недопустимые значения, отстуствующие значения, орфографические ошибки, устранение многозначности,
# перестановка слов, работа с вложенными значениями, нарушение уникальности, дублирование данных, противоречивость данных, неверные ссылки и логические связи

# -----------
# один из мощных инсрументов, который может прийти на помощь - регулярные выражения (regex)

# обнаружение соответствий
x <- c("apple", "banana", "pear")
str_detect(x, "e")

# Полезные функции:
# str_view()
# str_count()
# str_subset()
# str_replace()