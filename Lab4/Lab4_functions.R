renv::init() # инициализация виртуального окружения
renv::install() # установка библиотеки из CRAN
renv::snapshot() # делаем снимок версий библиотек в нашем виртуальном окружении
# фиксируем этот список в .lock-файле для возможности восстановления
# renv::restore() # команда отктиться к предыдушему удачному обновления библиотек

# ------------------- 
# Лабораторная работа №4:
# Написание функций.

# ----------------Общий синтаксис функций, глобальная и локальная области видимости

g <- function(x){
  return(x+1)
}

g(
  as.integer(
    readline("Введите Ваши данные в консоли ниже: ")))


?"{"

formals(g)

body(g)

# Поскольку функции являются объектами, их можно присавивать, передавать в аргументах другим функциям

f1 <- function(a, b) return(a + b)
f2 <- function(a, b) return(a - b)

f <- f1
f(3, 2)

f <- f2
f(3,2)


g <- function(h, a, b) h(a,b)
g(f1, 3,2)

g(f2, 3,2)


# А поскольку функции являются объектами, вы можете перебрать элементы списка нескольких функций.
# Например, такой перебор может использоваться для вывода графиков нескольких функций на одной дигаграмме.

g1 <- function(x) return(sin(x))
g2 <- function(x) return(sqrt(x^2+1))
g3 <- function(x) return(2*x-1)
plot(c(0,1), c(-1,1.5)) # подготовить график, задать диапазоны X, Y ranges
for (f in c(g1, g2, g3)) plot(f, 0,1, add=T) # добавляем график на диаграмму

# Функции formals(), body() даже могут использоваться в качестве функций замены.
# А вот так можно изменить тело функции присваиванием:

g <- function(h, a, b) h(a,b)
body(g) <- quote(2*x+3)
g

x <- 3
g(3)

# таким образом мы можем менять тело функции (!) и делать ее переменной (!),
# а также менять ее в цикле (!)

# без вызова quote() R повытается вычислить величину 2*x+3Б тк с технической точки зрения тело функции имеет класс
# "call", создаваемый вызовом quote()


# Окружение и проблема видимости
w <- 12
f <- function(y){
  d <- 8
  h <- function(){
    return(d*(w+y))
  }
  print(environment(h))
  return(h())
}

f(2) # локальная область видимости с адресом в памяти

environment(f) # а здесь глобальная область видимости
ls() # функция выводит список объектов в окружении
ls.str()

# существует иерархия видимости



#---------------- Работа с Environments
e1 <- new.env(parent = baseenv())  # создали еще одно окружение

assign("x1", 
       c(1:1000), 
       envir = e1 # создали переменную х1 и записали ее в окружение е1
)


assign("y1", 
       c(1:1000), 
       envir = e1
)

# а вот здесь - интересно!
assign("test_cmp", # создаем функцию с названием test_cmp
       compiler::cmpfun( # вызываем библиотеку перевода в бинарный код
         function(x1,y1){ # именно эту функцию мы переводим в бинарный код
           z <- x1^2 + y1^2 # это ее тело
           Reduce("+", z) # здесь фнкция + (сумма) проходит по вектору z
         }
       ),
       envir = e1 # и все это мы делаем в специальном окружении е1, так что не захламляем переменными Глобальное окружение
)

do.call("test_cmp", # вызываем функцию, которую мы упаковали в бинарный код для скорости
        list(as.name("x1"), as.name("y1")), 
        envir = e1)

formals("test_cmp", envir = e1)
body(get("test_cmp", envir = e1))
get("x1", envir = e1)


ls() # смотрим список объектов глобального окружения
ls(e1) #  смотрим список объектов вложенного окружения e1
View(body(get("test_cmp", envir = e1)))


# сравним скорость бинарной функции и обычной
system.time(
  do.call("test_cmp", # вызываем функцию, которую мы упаковали в бинарный код для скорости
          list(as.name("x1"), as.name("y1")), 
          envir = e1)
)

x1 <- c(1:1000)
y1 <- c(1:1000)
slow <- function(x1,y1){ 
  z <- x1^2 + y1^2 
  Reduce("+", z) 
}
system.time(
  slow(x1,y1)
)


# ---------------- Оператор восходящей записи
# нужен тогда, когда переменные из локальной области видимости нужно перенести в Глобальную для использования в расчетах

global_f <- function(x,y){
  local <- x+y
  return(local)
}
global_f(2,3) # обратите внимание - в Глобальном окружении сейчас есть только global_f


make_global <- function(u){
  u<<- 2*u
  z <- 2*z
}

x <- 1
z <- 3
u # на этом этапе переменная U еще не существует в Глобальном окружении, тк родительская ф-ия еще не вычислялась

make_global(x)
x
z
u # а сейчас переменная U существует


# -------------- Анонимные функции
m <- matrix(c(1:10), nrow = 2)
m
anonymous_f <- apply( # применяем
  m, # к данным под названием m
  2, # построчно
  function(x) x*2 # эту функцию
)

anonymous_f


# ------------------Замыкания
# закончим тему функций замыканиями - разновидностью функций, которые создают локальную переменную, а затем
# создают другую функцию, обращающуюся к этой переменной.
counter <- function(){
  ctr <- 0
  f <- function(){
    ctr <<- ctr + 1
    cat("У этого счетчика уже есть значение", ctr, "\n")
  }
  return(f)
}

c1 <- counter()
c2 <- counter()
c1
c2

c1()
c1() # обратите внимание, что счетчик увеличился!

c2()
c2() # здесь также 

# Почему?
# Ключевой момент - при разных вызовах counter() переменная ctr будет находиться в разных окружениях (с разными адресами в памяти).
# Иначе говоря, разные вызовы counter() будут создавать физически разные экземпляры ctr.
#  В результате функции c19, c2() работают как полностью независимые счетчики.
