#Этот пакет (файл) содержит измерения на 200 швейцарских банкнотах: 100 подлинных и 100 поддельных. 
#Переменными являются длина счета, ширина левого края, ширина правого края, ширина нижнего поля и ширина верхнего поля.
#Все измерения в миллиметрах. Источник данных указан ниже. Эти данные также доступны в пакете alr в R.
library(alr4)
library(alr3)
data(banknote)
head(banknote)
baknote.01<-read.table("swiss.csv",sep="",header=TRUE)
head(baknote.01)
baknote.02<-baknote.01[,-1]
head(baknote.02)
key<-c(rep(1,100),rep(0,100))
baknote.03<-sapply(baknote.03[1:6],as.numeric)
baknote.03<-data.frame(baknote.03,key)
#Знакомимся с данными
str(baknote.03)
head(baknote.03)
dim(baknote.03)
ncol(baknote.03)
nrow(baknote.03)
summary(baknote.03)
hist(baknote.03$Length) 
hist(baknote.03$Height.left)
hist(baknote.03[,3])
hist(baknote.03[,4])
hist(baknote.03[,5])
hist(baknote.03[,6])
#обратим внимание на то, что количество столбцов диаграммы задается автоматически.
#Диаграммы не сравнимы друг с другом. Хотелось бы на одном рисунке увидеть все 6 диаграмм
#Давайте изобразим на одном рисунке все 6 диаграмм
# Может быть ошибка построения нужно раcширить окно графики
#Перед строкой, вызывающей проблему, попробуйте:
# можно поэкспериментировать вот с таким кодом(не разбирался сам)
par(mar = rep(2, 4))
затем подготовьте второе изображение

image(as.matrix(leg),col=cx,axes=T)
Вам нужно будет поэкспериментировать с размером полей 
на par()звонке, который я показываю, чтобы понять это правильно. 
Вам также может потребоваться увеличить размер фактического устройства,
на которое вы наносите изображение.

Последний совет: сохраните par()значения по умолчанию 
перед их изменением, поэтому измените существующий par()вызов на:
  
  op <- par(oma=c(5,7,1,1))
тогда в конце сюжета делаю

par(op)
#
par(mfrow=c(1,6))
hist(baknote.03$Length) 
hist(baknote.03$Height.left)
hist(baknote.03[,3])
hist(baknote.03[,4])
hist(baknote.03[,5])
hist(baknote.03[,6])
#Завершение разбиения на окна. Возврат к стандартной графической консоли
dev.off()
# по умолчанию ширина столбца вычисляется по правилу “Sturges'а”, 
#  по правилу Sturges'а  число столбцов   k = log2(n)+1
#  правильнее, когда  k ~ n^(1/3)
# опция breaks позволяет задать количество столбцов. НИже представлены варианты

hist(baknote.03[,5], breaks="Scott")
hist(baknote.03[,6],breaks="Freedman-Diaconis")
hist(baknote.03[,6],breaks=18)
hist(baknote.03[,5], breaks=18)
par(mfrow=c(1,2))
dev.off()
#Обратимся к статистике, как науке о данных.
# для сравнения диаграмм нужно добиться их идентичности. Для этого обычно 
#смотрят на распределение, как на плотность вероятности событий
#Добиваются это с помощью следующей команды. Площадь по графиком = 1. 
# Работая с гистограммой главное понимать, что мы работаем с площадью, то есть
# с вероятностью события. Для большего понимания нужно экспериментировать с
# с количеством интервалов (подставьте 10-30)

hist(baknote.03[,6], breaks =20, probability=TRUE)

#Что показывает график? Он показывает на то, что данные разделены на 2 части
#возможно именно диагональ и является главным фактором, которые
#фальшивомонетчики не смогли подделать
#Давайте поиграем данными с помощью разных графических представлений
plot(baknote.03[,1], baknote.03[,6])

#построили график зависимости диагонали от длины банкноты. Что плохого. 
#все точки одинаковы.Раскрасим их разными цветами.
plot(baknote.03[,1], baknote.03[,6], type="n", xlab="Длина", 
     ylab="Диагональ", main="Швейцарские банкноты")
# type="n" позволяет подготовить пустую диаграмму
#Добавляем точки для фальшивых и настоящих банкнот
#настоящие (не фальшивые)
points(baknote.03[,1][baknote.03$key==1], 
       baknote.03[,6][baknote.03$key==1],pch=4)
#фальшивые
points(baknote.03[,1][baknote.03$key==0], 
       baknote.03[,6][baknote.03$key==0],pch=3)
#параметр pch обозначает тип точки. Поэкспериментируйте с этим параметром.См. Help

#теперь играем цветом(параметр Col)
plot(baknote.03[,1], baknote.03[,6], type="n", xlab="Длина", 
     ylab="Диагональ", main="Швейцарские банкноты")
# type="n" позволяет подготовить пустую диаграмму
#Добавляем точки для фальшивых и настоящих банкнот
#настоящие (не фальшивые)
points(baknote.03[,1][baknote.03$key==1], 
       baknote.03[,6][baknote.03$key==1],col=4)
#фальшивые
points(baknote.03[,1][baknote.03$key==0], 
       baknote.03[,6][baknote.03$key==0],col=3)
#играем цветом и типом одновременно
plot(baknote.03[,1], baknote.03[,6], type="n", xlab="Длина", 
     ylab="Диагональ", main="Швейцарские банкноты")
# type="n" позволяет подготовить пустую диаграмму
#Добавляем точки для фальшивых и настоящих банкнот
#настоящие (не фальшивые)
points(baknote.03[,1][baknote.03$key==1], 
       baknote.03[,6][baknote.03$key==1],col=4,pch=3)
#фальшивые
points(baknote.03[,1][baknote.03$key==0], 
       baknote.03[,6][baknote.03$key==0],col=3,pch=4)
#А теперь матрица диаграмм рассеивания. Крутая штука!
plot(baknote.03)

#уберем последний столбец. Он не информативен для этой диаграммы
plot(baknote.03[,1:6])
names(baknote.03)

# украсим диагрмму рассеивания
pairs(baknote.03[,1:6], main = "Швейцарские банкноты",
      pch = c(21), cex = 1, bg = c("red","green3","blue"))
#cex - размер кружков (поставьте 0.4; 2; 5); bg - цвет кружков
# pch = c(21) - тип точек на диаграмме рассеивания поэкспериментируйте и сделайте выводы
# посмотрим теперь на переменную key
str(baknote.03)
# она у нас имеет тип числовой (num). На самом деле это не число. Это фактор.
#поскольку мы закодировали 0 - фальшивые банкноты, 1 - настоящие.
#превратим ее в фактор.
baknote.03$key <- as.factor(baknote.03$key) 
str(baknote.03)
# переменная key стала фактором, который имеет 2 уровня 0 и 1, но кодируется он сейчас 
# числами 1 (0 уровень фактора) и 2(1 уровень фактора).
is.factor(baknote.03$key) #проверили фактор или нет
class(baknote.03$key) #проверили фактор или нет
#очень полезным инструментом для анализа данных является диаграмма "ящик с усами"
#при ее построении первым указывается переменная - фактор, второй необходимая переменная для анализа данных
#в нашем случае диагональ
plot(baknote.03$key, baknote.03[,6])

# Подпишем диаграмму, введем оси. 
plot(baknote.03$key, baknote.03[,6],xlab="Длина", 
     ylab="Диагональ", main="Швейцарские банкноты" )
# поменяем название заголовка диаграммы вверху и внизу. Как убрать наложения?
title("Диаграмма", "Швейцарские банкноты 20-х годов")

#еще один способ построить ящики с усами или гистограммы

boxplot(baknote.03$key, baknote.03[,6])
boxplot(baknote.03[,6])

#посмотрим еще на возможности R. Воспользуемся кодом Oxford университета
#преобразуем его относительно наших данных. мы видим еще один способ задать цвета


couleurs=c("0"='blue',"1"='red')
couleurs['0']
couleurs[baknote.03$key]
plot(baknote.03[,6],baknote.03[,4],col=couleurs[baknote.03$key])

#Аналогично можно определить вид точек, опция pch

pchurs=c("0"='x',"1"='o')
pchurs['0']
pchurs[baknote.03$key]
plot(baknote.03[,6],baknote.03[,4],pch=pchurs[baknote.03$key])

#Аналогично можно определить вид точек, опция pch

pchurs=c("0"=3,"1"=4)
pchurs['0']
pchurs[baknote.03$key]
plot(baknote.03[,6],baknote.03[,4],pch=pchurs[baknote.03$key])

# еще способ

plot(baknote.03[,-7],col=couleurs[baknote.03$key],pch='x')

#реализуем трехмерную графику с помощью пакета rgl
install.packages("rgl")
library(rgl)
plot3d(baknote.03[,c(4:6)],col=couleurs[baknote.03$key],type="s") 
# В данном случае берем столбцы 4,5,6. Можно провести эксперименты и с другими вариантами

# проведем анализ данных с помощью другого инструмента. загрузим пакет  ade4
install.packages("ade4")
library(ade4)
acp=dudi.pca(baknote.03[,1:6],scann=FALSE,n=2)
inertie=inertia.dudi(acp,row.inertia=TRUE,col.inertia=TRUE)
scatter(acp)
s.class(acp$li,fac=baknote.03$key,xax=1,yax=2,col=c('red','blue'))
# что же означают эти команды? Для этого давайте зайдем на сайт языка R
# https://cran.r-project.org/ выберем раздел Packages (слева).
# Найдем нужный пакет (выбрав способ показа по алфавиту, sortbyname)
# Откроем руководство пакета и найдем команду dudi.pca
# Рассмотрите ее синтаксис самостоятельно и разберитесь как она работает
# по сути, команда представляет метод "анализ главных компонент".

acp$lw # poids sur les lignes
acp$cw # poids sur les colonnes
head(acp$tab) #$ matrice apre`s transformation
G=t(as.matrix(acp$tab))%*%diag(acp$lw)%*%as.matrix(acp$tab) # matrice de Gram
cor(acp$tab)
cor(baknote.03[,1:6])
inertie$TOT
barplot(acp$eig,main="eboulis des valeurs propres",col="red",names.arg=paste("sigma",1:6,"^2",sep=""))

